package com.qualoutdoor.recorder.persistent;

import java.util.ArrayList;

import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.util.SparseArray;

/**
 * Class interfacing between java code of android app and SQL local database.
 *  */


public class SQLConnector {

    /**database to interact with*/
    private SQLiteDatabase db;
    /**database creator*/
    private SQLDataBaseCreator dbCreator;
    /**database manager for inserting measure into database in following tree architecture*/
    private DataBaseTreeManager manager;
    /**Memory cache for leaf insertion in tree*/
    private MeasureContext oldContext;
    /** Value indicating if this connector is open already */
    private boolean isOpen = false;

    /**Constructor
     * that calls database creator one*/
    public SQLConnector(Context context) {
        this.dbCreator = new SQLDataBaseCreator(context);
        this.oldContext = new MeasureContext();
    }

    /**
     * Method triggering the database content creation or if it's already done
     * it just get its content 
     * */
    public void open() throws SQLException {
        // creation or opening of database content
        this.db = this.dbCreator.getWritableDatabase();
        // manager initialization
        this.manager = new DataBaseTreeManager(this.db,
                this.dbCreator.getTableReference());
        // The connector is now opened
        this.isOpen = true;
    }

    /**
     * Method for closing access to the database
     * */
    public void close() {
        this.dbCreator.close();
        // The connector is now closed
        this.isOpen = false;
    }

    /** 
     * Indicate if this connector is open already
     */
    public boolean isOpen() {
        return this.isOpen;
    }

    /**
     * Method for inserting a new leaf into reference table
     */
    public void insertReference(MeasureContext newContext, int ref)
            throws CollectMeasureException, DataBaseException {
        // checking if contexts are coherents
        if (this.oldContext.getlength() != newContext.getlength()
                || this.oldContext.getCursor() != newContext.getCursor()) {
            throw new CollectMeasureException(
                    "new context doesn't match with old one");
        }
        // when nodes are the same for old and new context
        if (newContext.getStage(newContext.getCursor()) == this.oldContext
                .getStage(this.oldContext.getCursor())) {
            // if end of the tree is reached, it's time to insert leaf where manager is pointing
            if (this.oldContext.isAtEnd()) {
                this.manager.insertLeaf(ref);
            } else {
            // if it's not, insertReference is call again on the context but focusing of the stage under the current one   
               //moving down on both context
                this.oldContext.moveToChild();
                newContext.moveToChild();
                //calling againg the methode
                insertReference(newContext, ref);
            }
        } else {
        //if nodes are different, distance between leaves and last shared node is calculated for 
        //making manager recovering untill this node before going down along the right branch
            int distFatherLeaf = this.oldContext.getlength()
                    - this.oldContext.getCursor();
            // manager is recovering
            for (int i = 0; i < distFatherLeaf; i++) {
                this.manager.getFather();
            }
            // manager is going along the right branch
            for (int u = 0; u < distFatherLeaf; u++) {
                manager.findOrCreate(newContext.getStage(newContext.getCursor()));
                // old context is updated with the new manager position
                this.oldContext.set(this.oldContext.getCursor(),
                newContext.getStage(newContext.getCursor()));
                this.oldContext.moveToChild();
                newContext.moveToChild();
            }
            //when end of tree is reached it's time to insert leaf where manager is pointing
            this.manager.insertLeaf(ref);
        }

    }

    

    /**
     * Method for inserting leaf's details into measure table of the database,
     * returns inserted line id or -1 if insertion went wrong.
     */
    public int insertData(double lat, double lng, String data)
            throws DataBaseException {
        int id = -1;
        // preparing SQL statement for insertion, date is generated by MySQL
        String insertQuery = "INSERT INTO "
                + this.dbCreator.getTableMeasure().getName()
                + " ( LAT , LNG, DATA) VALUES (" + lat + "," + lng + ", '" + data
                + "' );";
        //executing it
        db.execSQL(insertQuery);
        //getting last inserted row id
        Cursor c = db.rawQuery("SELECT last_insert_rowid()", null);
        if (c.moveToFirst()) {
            id = c.getInt(0);
        } else {
            throw new DataBaseException(
                    "SQL CONNECTOR : can't find ID of inserted measure ! ");
        }
        return id;
    }

    /**
     * Method inserting a full measure into local database
     * */
  
    public void insertMeasure(MeasureContext newContext,
            SparseArray<String> data, double d, double e)
            throws DataBaseException, CollectMeasureException {
        int ref;
        int size = data.size();
        for (int index = 0; index < size; index++) {
            //for every leaf context is completed
            newContext.set(newContext.getlength() - 1, data.keyAt(index));
            //both cursors are reset for make sure that they are coherent
            this.oldContext.resetCursor();
            newContext.resetCursor();
            //inserting leaf details into measure table
            ref = this.insertData(d, e, data.valueAt(index));
            //inserting leaf into reference table
            this.insertReference(newContext, ref);
        }
    }


    /**
     * Returns details of the specified leaf
     */
    public ArrayList<String> getLeafDetails(int ref) throws DataBaseException {
        ArrayList<String> list = new ArrayList<String>();
        //preparing SQL statement
        String selectQuery = "SELECT DATE , LAT , LNG , DATA FROM "
                + this.dbCreator.getTableMeasure().getName() + " WHERE ID = ?";
        //executing it
        Cursor c = db.rawQuery(selectQuery, new String[] {
            Integer.toString(ref)
        });
        if (c.moveToFirst()) {
            for (int i = 0; i < c.getColumnCount(); i++) {
                //filling the list with found results
                list.add(c.getString(i));
            }
            return list;
        } else {
            throw new DataBaseException("can't find leaf ");
        }
    }

    /**
     * Returns a manager initialized on the tree stored into reference table
     */
    public DataBaseTreeManager prepareManager() throws DataBaseException {
        DataBaseTreeManager manager = null;
        manager = new DataBaseTreeManager(this.db,
                this.dbCreator.getTableReference());
        return manager;
    }

    /**
     * Checking if the stored tree is not empty : consists in counting lines of measures table
     */
    public boolean hasLeaf() {
        boolean bool;
        // preparing SQL statement
        String selectQuery = "SELECT ID FROM "
                + this.dbCreator.getTableMeasure().getName();
        //exectuting it
        Cursor c = db.rawQuery(selectQuery, null);
        if (c.moveToFirst()) {
            //if leaves are found
            bool = true;
        } else {
            //if not
            bool = false;
        }
        c.close();
        return bool;
    }

  /**
   * Reseting the whole local storage system after file sending
   * */
    public void completeReset() throws DataBaseException {
        //dropping tables
        db.execSQL("DROP TABLE IF EXISTS '"
                + this.dbCreator.getTableReference().getName() + "' ");
        db.execSQL("DROP TABLE IF EXISTS '"
                + this.dbCreator.getTableMeasure().getName() + "'");
        this.dbCreator.onCreate(db);
        //reseting cursors
        this.oldContext.reset();
        this.manager.reset();

    }

}
